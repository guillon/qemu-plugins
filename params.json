{
  "name": "qemu-plugins",
  "tagline": "",
  "body": "================\r\nQEMU TCG Plugins\r\n================\r\n\r\n:Version: 1.2\r\n:Date: 2012-01-10\r\n:Copyright: STMicroelectronics\r\n\r\n.. sectnum::\r\n\r\n.. contents::\r\n\r\n\r\nIntroduction\r\n============\r\n\r\nThe TCG plugin support introduced in QEMU currently allows an external\r\nshared library to be notified each time a basic block is translated\r\ninto the TCG internal representation, in the aim of instrumenting the\r\nemulated code to produce program analysis, Ã  la Valgrind or DynamoRIO\r\nfor instance.\r\n\r\nThere are already five plugins available by default:\r\n\r\nicount\r\n    Count the number of executed *guest* instructions per CPU and\r\n    produce a summary report each time CPUs are stopped::\r\n\r\n        Number of executed instructions on CPU #0 = 678234533\r\n        Number of executed instructions on CPU #1 = 36475675\r\n\r\nicount-inlined\r\n    Same as above but this plugin is *not* based on a helper, instead\r\n    it inserts TCG opcodes inlined right at the beginning of each\r\n    basic block, see `How to Write TCG Plugins?`_ for details.  This\r\n    method is quite faster [#]_ but the current implementation is\r\n    *not* thread-safe.\r\n\r\n.. [#] Christophe GUILLON: Program Instrumentation with QEMU.  In 1st\r\n       International QEMU Users' Forum 2010.\r\n\r\ntrace\r\n    Print the address/size/name of the current emulated basic block.\r\n    This is quite useful to find where two runs diverge or where a\r\n    segmentation fault occurred::\r\n\r\n        [...]\r\n        CPU #0 - 0x00008270 [32]: 8 instruction(s) in '/tmp/a.out:main'\r\n        CPU #0 - 0x00008230 [48]: 12 instruction(s) in '/tmp/a.out:test'\r\n        CPU #0 - 0x00010ac0 [12]: 3 instruction(s) in '/lib/ld-2.10.1.so:memcpy'\r\n        CPU #0 - 0x00010b54 [32]: 8 instruction(s) in '/lib/ld-2.10.1.so:memcpy'\r\n        Segmentation fault\r\n\r\n        $ addr2line -e a.out 0x00008230\r\n        /usr/local/cedric/test.c:13\r\n\r\n    Note that this plugin doesn't produce a call trace; for instance\r\n    the function ``memcpy()`` isn't called twice in the previous\r\n    example, there were just two basic blocks executed consecutively.\r\n\r\nprofile\r\n    Count the number of executed *guest* bytes/instructions per symbol\r\n    and produce a profile report each time CPUs are stopped::\r\n\r\n        SYMBOL       | FILENAME            | #BYTES | #INSTR\r\n        ----------------------------------------------------\r\n        test         | /tmp/a.out          |     48 |     12\r\n        memcpy       | /lib/ld-2.10.1.so   |    168 |     42\r\n        main         | /tmp/a.out          |     32 |      8\r\n        [...]\r\n\r\ndineroIV\r\n    Print the address/size/cpu of each loaded/stored data in a format\r\n    supported by DineroIV, a highly configurable cache simulator::\r\n\r\n        w 0x000000000046ca20 0x00000004 (0x0000000000000000) CPU #0 0x0000000000401e3c\r\n        w 0x000000000046ca24 0x00000004 (0x0000000000000000) CPU #0 0x0000000000401e3e\r\n        r 0x000000000046ca1c 0x00000004 (0x0000000000000001) CPU #0 0x0000000000401e46\r\n        w 0x000000000046ca1c 0x00000004 (0x0000000000000000) CPU #0 0x0000000000401e4a\r\n        r 0x000000000046bae0 0x00000004 (0x000000000046ba14) CPU #0 0x0000000000401e5c\r\n        w 0x000000000046bb14 0x00000004 (0x00000000ffffffff) CPU #0 0x0000000000401e62\r\n\r\n    This is a really good alternative to Cachegrind.\r\n\r\n    Refer to README.dineroIV for usage.\r\n\r\n\r\nHow to Use TCG Plugins?\r\n=======================\r\n\r\nQEMU doesn't enable the TCG plugin support by default, you have to\r\nspecify the option ``--enable-tcg-plugin`` to the ``configure``\r\nscript.  Then, both the system-mode and user-mode use the same\r\ncommand-line interface::\r\n\r\n    $ qemu-arm -tcg-plugin ./tcg-plugin-trace.so ...\r\n\r\nYou can also use the short-form name for plugins that are installed in\r\nthe plugin directory (default is ``/usr/local/libexec/qemu``)::\r\n\r\n    $ qemu-arm -tcg-plugin trace ...\r\n\r\nSome sanity checks are performed when the shared library is loaded to\r\nensure it is compatible with the current version of the TCG plugin\r\ninterface used by QEMU.  For instance you may encounter such errors::\r\n\r\n    plugin: error: <errors from the dynamic linker>\r\n    plugin: error: initialization has failed\r\n    plugin: error: incompatible plugin interface\r\n    plugin: error: incompatible CPUState structure size\r\n    plugin: error: incompatible TranslationBlock structure size\r\n\r\nHowever some checks only warn the user that a component *may* not be\r\ncompatible, which technically this could lead to unexpected\r\nbehaviors (see `Generic Plugin`_ for explanation)::\r\n\r\n    plugin: warning: incompatible guest CPU\r\n    plugin: warning: incompatible emulation mode\r\n\r\nAll plugins share a common set of options passed through environment\r\nvariables:\r\n\r\nTPI_OUTPUT=file\r\n    Specify where the plugin writes information: ``file``.``$PID``,\r\n    this IO stream is line-buffered unless the default output is used\r\n    (``stderr``).\r\n\r\nTPI_VERBOSE\r\n    Print information about the loaded plugin (in TPI_OUTPUT).\r\n\r\nTPI_LOW_PC\r\n    Specify the lowest PC address (*inclusive*) for which the plugin\r\n    is notified.\r\n\r\nTPI_HIGH_PC\r\n    Specify the highest PC address (*exclusive*) for which the plugin\r\n    is notified.\r\n\r\nTPI_SYMBOL_PC=name\r\n    Define TPI_LOW_PC/TPI_HIGH_PC according to the value/size of the\r\n    symbol ``name``. This option isn't supported yet.\r\n\r\nTPI_MUTEX_PROTECTED\r\n    Protect the call to ``pre_tb_helper_code`` with a mutex.\r\n\r\nNote that currently notification works in a per basic block basis,\r\nthat is, the plugin is notified for any basic block that contains\r\nTPI_LOW_PC or TPI_HIGH_PC.\r\n\r\n\r\nHow to Write TCG Plugins?\r\n=========================\r\n\r\nBuild System\r\n------------\r\n\r\nBy default, any ``.c`` file lying in the directory ``tcg/plugins`` is\r\nconsidered to be a single plugin source.  If you had to specify\r\nspecific CLFAGS/LDFLAGS for your plugin, just add them in the file\r\n``Makefile.target`` like it was done for the ``profile`` plugin::\r\n\r\n    tcg-plugin-profile.o: CFLAGS += $(shell pkg-config --cflags glib-2.0)\r\n    tcg-plugin-profile.so: LDFLAGS += $(shell pkg-config --libs glib-2.0)\r\n\r\n\r\nInitialization\r\n--------------\r\n\r\nOnce the shared library is loaded into QEMU's address space, its\r\n``tpi_init()`` function is called to initialize the TCG plugin::\r\n\r\n    #include \"tcg-plugin.h\"\r\n    void tpi_init(TCGPluginInterface *)\r\n\r\nFirst, this function has to fill in the fields of\r\n``TCGPluginInterface`` related to *compatibility* information so that\r\nQEMU can perform the sanity checks described in section `How to Use\r\nTCG Plugins?`_::\r\n\r\n    struct TCGPluginInterface\r\n    {\r\n        /* Compatibility information.  */\r\n        int version;\r\n        const char *guest;\r\n        const char *mode;\r\n        size_t sizeof_CPUState;\r\n        size_t sizeof_TranslationBlock;\r\n        \r\n        /* Common parameters.  */\r\n        int nb_cpus;\r\n        FILE *output;\r\n        uint64_t low_pc;\r\n        uint64_t high_pc;\r\n        bool verbose;\r\n        \r\n        /* Parameters for non-generic plugins.  */\r\n        bool is_generic;\r\n        const CPUState *env;\r\n        const TranslationBlock *tb;\r\n        \r\n        /* Plugin's callbacks.  */\r\n        tpi_cpus_stopped_t cpus_stopped;\r\n        tpi_before_gen_tb_t before_gen_tb;\r\n        tpi_after_gen_tb_t  after_gen_tb;\r\n        tpi_pre_tb_helper_code_t pre_tb_helper_code;\r\n        tpi_pre_tb_helper_data_t pre_tb_helper_data;\r\n        tpi_after_gen_opc_t after_gen_opc;\r\n    };\r\n\r\nFor convenience, there are two C macros that automatically set these\r\nfields.  The former macro uses proper values (``\"arm\"``, ``\"user\"``,\r\n...) whereas the latter uses generic values (``\"any\"`` or ``0``) that\r\ntell QEMU to skip some checks for `generic plugin`_.  Both macros set\r\n``version`` to the value TPI_VERSION defined in ``tcg-plugin.h``, but\r\nthis field can be set to ``0`` if the TCG plugin wants to report an\r\ninitialization failure to QEMU::\r\n\r\n    TPI_INIT_VERSION(TCGPluginInterface)\r\n\r\n    TPI_INIT_VERSION_GENERIC(TCGPluginInterface)\r\n\r\nThen, this function is used to declare each callback implemented by\r\nthe plugin, see next section for details.  Here is an example::\r\n\r\n    tpi->pre_tb_helper_code = pre_tb_helper_code;\r\n    tpi->cpus_stopped = cpus_stopped;\r\n\r\n\r\nTranslation-Time Callbacks\r\n--------------------------\r\n\r\nThere are currently four regular callbacks available, all are called\r\nat `translation-time`_, see `Two Kinds of Flow`_ for details.  In the\r\nfollowing descriptions, the short terms *tb* and *opc* stand for\r\n*Translated Block* and *Operation Code* respectively.  Note that a\r\ngiven plugin doesn't have to provide all of these callbacks, they are\r\n*all* optional.\r\n\r\n\r\ncpus_stopped\r\n````````````\r\n\r\nThis function is called when all emulated CPUs are stopped (on exit,\r\nreboot, ...) and is mainly used to print analysis reports.  Its\r\ndeclaration is::\r\n\r\n    void cpus_stopped(const TCGPluginInterface *tpi)\r\n\r\n\r\nbefore_gen_tb\r\n`````````````\r\n\r\nThis function is called before a basic block is translated from\r\n*guest* instructions to TCG opcodes, and it is mainly used to insert\r\nTCG opcodes or calls to helpers.  Its declaration is::\r\n\r\n    void before_gen_tb(const TCGPluginInterface *tpi)\r\n\r\n\r\nafter_gen_tb\r\n````````````\r\n\r\nThis function is called after a basic block is translated from *guest*\r\ninstructions to TCG opcodes, and it is mainly used to patch the value\r\nof variables that were undefined when ``before_gen_tb()`` was called,\r\nthis is typically the case for ``tb->size`` and ``tb->icount``.  Its\r\ndeclaration is::\r\n\r\n    void after_gen_tb(const TCGPluginInterface *tpi)\r\n\r\n\r\nafter_gen_opc\r\n``````````````\r\n\r\nThis function is called after a TCG opcode is emitted, and it is\r\nmainly used to insert TCG opcodes or calls to helpers.  Its\r\ndeclaration is::\r\n\r\n    void after_gen_opc(uint16_t *opcode, TCGArg *opargs, uint8_t nb_args);\r\n\r\n\r\n\r\nCallbacks for Predefined Helpers\r\n--------------------------------\r\n\r\nThere are two predefined helpers, the first one is called *before* the\r\nexecution of a translated block (`execution-time`_) and the second one\r\nis called *after* the translation of a opcode (`translation-time`_).\r\nNote that a given plugin doesn't have to provide all of these\r\ncallbacks, they are *all* optional.\r\n\r\n\r\npre_tb_helper_code\r\n``````````````````\r\n\r\nThis function is called each time a translated basic block is executed\r\nand is mainly used to collect analysis data.  Its declaration is::\r\n\r\n    void pre_tb_helper_code(const TCGPluginInterface *tpi,\r\n                        TPIHelperInfo info, uint64_t address,\r\n                        uint64_t data1, uint64_t data2)\r\n\r\nWhen QEMU calls this function, a mutex is used to avoid than more one\r\nthread executes it at the same time.  That means the resources only\r\nused by this function are protected from concurrent access.\r\n\r\nThe parameter ``info`` is a 64-bit structure defined as below.  Its\r\nfields ``size`` and ``icount`` are respectively the size of, and the\r\nnumber of *guest* instructions in, the translated basic block.  These\r\ntwo fields are set to ``0`` when QEMU is re-translating an interrupted\r\nblock::\r\n\r\n    typedef struct\r\n    {\r\n        uint16_t cpu_index;\r\n        uint16_t size;\r\n        uint32_t icount;\r\n    } __attribute__((__packed__)) TPIHelperInfo;\r\n\r\nThe optional parameters ``data1`` and ``data2`` are defined at\r\ntranslation-time by the function ``pre_tb_helper_data()``, that means they\r\nkeep their initial values (for a given basic block) during the\r\nexecution.\r\n\r\n.. TODO: explain why called before the execution of the translated\r\n         block (safest + most useful)\r\n\r\n\r\npre_tb_helper_data\r\n``````````````````\r\n\r\nThis function is called each time a basic block *was* translated\r\n(**not executed**) and is mainly used to define the parameters passed\r\nto ``pre_tb_helper_code()``.  Its declaration is::\r\n\r\n    void pre_tb_helper_data(const TCGPluginInterface *tpi,\r\n                            TPIHelperInfo info, uint64_t address,\r\n                            uint64_t *data1, uint64_t *data2)\r\n\r\nThe parameter ``info`` is the same as above and the pointers ``data1``\r\nand ``data2`` reference the eponymous parameters of\r\n``pre_tb_helper_code()`` for the given translated block.  Note that they\r\nare defined at translation-time, that is, they can't be changed later\r\non.  See `Two Kinds of Flow`_ for explanation.  Technically ``data1``\r\nand ``data2`` can hold anything and are particularly useful to\r\noptimize the execution of the ``pre_tb_helper_code()`` as described in\r\nsection `Optimization`_.\r\n\r\n\r\nTwo Kinds of Flow\r\n-----------------\r\n\r\nEvery plugin writer should keep in mind that there are two kinds of\r\nflow: translation-time and execution-time.\r\n\r\n\r\nTranslation-Time\r\n````````````````\r\n\r\nWhen the emulated program jumps to a portion of code not translated\r\nyet, QEMU invokes the Tiny Code Generator -- TCG for short -- to\r\nconvert *guest* CPU instructions into *host* CPU instructions.  This\r\nconversion happens only once per basic block [#X]_, that is, the next\r\ntime the emulated program jumps to this portion of code, the *host*\r\nversion of the basic block is executed directly [#X]_.  The\r\ntranslation flow looks like this diagram::\r\n\r\n    +---------------------------------+\r\n    | the program has branched to a   |\r\n    | basic block not translated yet  |\r\n    +---------------------------------+\r\n                     |\r\n            +------------------+\r\n            |  before_gen_tb() |\r\n            +------------------+\r\n                     |\r\n    +---------------------------------+\r\n    |     gen_intermediate_code()     |       +-------------------+\r\n    |  translates guest instructions  | - - - |     gen_opc()     |\r\n    |        into TCG opcodes         |       | opc_helper_data() |\r\n    +---------------------------------+       +-------------------+\r\n                     |\r\n          +----------------------+\r\n          |    after_gen_tb()    |\r\n          | pre_tb_helper_data() |\r\n          +----------------------+\r\n                     |\r\n    +---------------------------------+\r\n    |   TCG opcodes are translated    |\r\n    |      into host instructions     |\r\n    +---------------------------------+\r\n\r\n.. [#X] this isn't accurate, but it's OK for this explanation.\r\n\r\n\r\nExecution-Time\r\n``````````````\r\n\r\nAs said in the previous section, once *guest* instructions of a basic\r\nblock are translated to *host* instructions, they are executed\r\ndirectly when the emulated program jumps to this portion of code\r\n[#X]_.  That means any TCG opcodes and/or calls to helpers inserted at\r\ntranslation-time will be triggered each time this portion of code is\r\nexecuted.\r\n\r\nLet's take the example below::\r\n\r\n    block1:\r\n        i++\r\n        if i < 10\r\n            goto block1\r\n    block2:\r\n        i = 0\r\n        goto block1\r\n\r\nThe function ``pre_tb_helper_code()`` is called each time the translated\r\nversion of ``block1`` and ``block2`` are executed.  The execution flow\r\nlooks like this diagram::\r\n\r\n                    +<-------------------+<--+\r\n                    |                    |   |\r\n    +--------------------------------+   |   |\r\n    | pre_tb_helper_code() then the  |   |   |\r\n    | translated block1 are executed |   |   |\r\n    +--------------------------------+   |   |\r\n                    |                    |   |\r\n                    +------------------->+   |\r\n                    |                        |\r\n    +--------------------------------+       |\r\n    | pre_tb_helper_code() then the  |       |\r\n    | translated block2 are executed |       |\r\n    +--------------------------------+       |\r\n                    |                        |\r\n                    +----------------------->+\r\n\r\n\r\nAdvices\r\n-------\r\n\r\nDeterministic code generation\r\n`````````````````````````````\r\n\r\nWhen an asynchronous event interrupt the execution of a translated\r\nblock (typically an exception), QEMU has to re-translate the\r\ninterrupted block to create a mapping between host PC addresses and\r\nguest PC addresses, so as to retrieve which was the *virtual* guest PC\r\nwhen the interruption occurred.  That means the translation process has\r\nto be deterministic to ensure the mapping created during the\r\nre-translation is the same as in the initial translation.\r\n\r\nFor instance on x86_64 host, the TCG opcode ``movi_i64 tmp6,$value``\r\ncan be translated to two different host instructions (with two\r\ndifferent sizes) according to the value of its operands::\r\n\r\n    mov    $value,%ecx\r\n\r\nor::\r\n\r\n    movabs $value,%rcx\r\n\r\nIn this case the re-translation may create a wrong guest-host PC\r\nmapping that might crash QEMU.\r\n\r\n\r\nPointer\r\n```````\r\n\r\nAs a plugin writer, you shall not dereference at execution-time a\r\npointer that you aren't absolutely sure its contents will not be freed\r\nor moved.  For instance, you can't access safely at execution-time [a\r\nfield of] a ``TranslationBlock`` the way below since there's a chance\r\nthat sooner or later the pointer ``tb`` will be freed::\r\n\r\n    ... before_gen_tb(...)\r\n    {\r\n        ptr = tcg_const_ptr(tpi->tb);\r\n        // generate TCG opcodes that use\r\n\t// \"((TranslationBlock *)ptr)->flags\"\r\n    }\r\n\r\nInstead, you have to **copy** the needed field(s)::\r\n\r\n    ... before_gen_tb(...)\r\n    {\r\n        TCGv_i64 pc = tcg_const_i64(tpi->tb->flags);\r\n    }\r\n\r\n\r\nOptimization\r\n````````````\r\n\r\nIt's worth saying the more analysis is done at translation-time, the\r\nless analysis is done at execution-time.  For instance, you can call\r\n``lookup_symbol(pc)`` in ``pre_tb_helper_code()`` to get the name of the\r\nfunction currently executed, but it will be called each time the given\r\nblock is executed::\r\n\r\n    ... pre_tb_helper_code(...)\r\n    {\r\n        const char *symbol = lookup_symbol(address);\r\n    }\r\n\r\nSince the matching ``pc/symbol`` never changes, it's cheaper to call\r\n``lookup_symbol(pc)`` in ``pre_tb_helper_data()`` -- thus once per basic\r\nblock translation -- to store the result in ``data1`` and then use\r\nthis pointer directly in ``pre_tb_helper_code()``::\r\n\r\n    ... pre_tb_helper_code(...)\r\n    {\r\n        const char *symbol = (const char *)data1;\r\n    }\r\n\r\n    ... pre_tb_helper_data(...)\r\n    {\r\n        const char *symbol = lookup_symbol(address);\r\n        *data1 = (uint64_t)symbol;\r\n    }\r\n\r\nYou can go even further by analyzing the trace with a post-treatment\r\ntool, as the plugin ``dineroIV`` does.\r\n\r\n\r\nMulti-threading\r\n```````````````\r\n\r\nThe Tiny Code Generator is mono-threaded, however it can generate code\r\nthat is not, as it's typically the case when emulating a\r\nmulti-threaded program in user-mode.  As a consequence the plugin\r\nwriter has to take special care of the code she/he emits for\r\nexecution-time, either in the form of TCG opcodes or calls to helpers.\r\nFor instance the plugin ``icount-inlined`` produces code that is not\r\nthread-safe since there's a chance that several threads increment the\r\ncounter simultaneously in a non-atomic way.\r\n\r\n\r\nLimit of a TCG-based approach\r\n`````````````````````````````\r\n\r\nThere are two main limitations of an approach based on TCG: the first\r\none is that not all guest instructions are converted to TCG opcodes,\r\nsome are converted to a call to helper (typically floating point\r\ninstructions).  The second limitation is that there's no easy way to\r\nhandle a guest instruction while manipulating its TCG translation\r\n(note that one guest instruction is likely composed of several TCG\r\nopcodes).\r\n\r\n\r\nGeneric Plugin\r\n``````````````\r\n\r\nA plugin is considered to be *generic* -- and thus can use the macro\r\nTPI_INIT_VERSION_GENERIC() -- if it doesn't perform access to\r\n``tpi->env`` of ``tpi->tb`` since these structures are different from\r\none CPU and/or mode to another, unlike ``TPIHelperInfo``.  Actually\r\nwhen a plugin declares itself as generic, these two fields are always\r\n``NULL`` to avoid any mistake.  For instance the plugins ``icount``\r\nand ``icount-inlined`` basically do the same thing but this latter\r\nisn't generic because it can't be used with a version of QEMU built\r\nfor another CPU and/or mode.\r\n\r\n\r\nCustom Helper\r\n`````````````\r\n\r\nYou can define your own helper but it isn't really straightforward.\r\nTo explain how to do this, we will take a simple example::\r\n\r\n    void helper_example(uint64_t data)\r\n    {\r\n         printf(\"0x%016\" PRIx64 \"\\n\", data);\r\n    }\r\n\r\nFirst create a C header file -- let's say ``example-helper.h`` -- with\r\nthe following content::\r\n\r\n    #include \"exec/def-helper.h\"\r\n    DEF_HELPER_1(example, void, i64)\r\n    #include \"exec/def-helper.h\"\r\n\r\nThen, add the following code at the beginning of your plugin's\r\nsource::\r\n\r\n    #include \"tcg-op.h\"\r\n    #include \"example-helper.h\"\r\n    #define GEN_HELPER 1\r\n    #include \"example-helper.h\"\r\n\r\nNow you can *insert* a call to this helper in the prologue of any\r\ntranslated block::\r\n\r\n    ... before_gen_tb(...)\r\n    {\r\n        TCGv_i64 pc = tcg_const_i64((uint64_t)address);\r\n        gen_helper_example(pc);\r\n        tcg_temp_free_i64(pc);\r\n    }\r\n\r\nFinally, you have to *declare* the helper to QEMU::\r\n\r\n    ... tpi_init(...)\r\n    {\r\n        #define GEN_HELPER 2\r\n        #include \"example-helper.h\"\r\n    }\r\n\r\nFor information, the following table gives the matching between TCG\r\ntypes and C types:\r\n\r\n==================  ==================\r\nTCG types           C types\r\n==================  ==================\r\ni32                 uint32_t\r\ns32                 int32_t\r\nint                 int\r\ni64                 uint64_t\r\ns64                 int64_t\r\nf32                 float32\r\nf64                 float64\r\ntl                  target_ulong\r\nptr                 void *\r\nvoid                void\r\nenv                 CPUState *\r\n==================  ==================\r\n\r\n\r\nExample\r\n=======\r\n\r\nThe *full* code of a simplified version of the ``trace`` plugin is\r\ngiven as an example below.  As you can see, it uses the optimization\r\nexplained in a previous section::\r\n\r\n    #include <stdio.h>\r\n    #include <stdint.h>\r\n    #include <inttypes.h>\r\n\r\n    #include \"tcg-plugin.h\"\r\n    #include \"disas/disas.h\"\r\n\r\n    static void pre_tb_helper_code(const TCGPluginInterface *tpi,\r\n                               TPIHelperInfo info, uint64_t address,\r\n                               uint64_t data1, uint64_t data2)\r\n    {\r\n        const char *symbol = (const char *)(uintptr_t)data1;\r\n\r\n        fprintf(tpi->output, \"%d instruction(s) in '%s' @ %#lx\\n\",\r\n                info.icount, symbol, address);\r\n    }\r\n\r\n    static void pre_tb_helper_data(const TCGPluginInterface *tpi,\r\n                               TPIHelperInfo info, uint64_t address,\r\n                               uint64_t *data1, uint64_t *data2)\r\n    {\r\n        const char *symbol = lookup_symbol(address);\r\n        *data1 = (uintptr_t)symbol;\r\n    }\r\n\r\n    void tpi_init(TCGPluginInterface *tpi)\r\n    {\r\n        TPI_INIT_VERSION_GENERIC(*tpi);\r\n        tpi->pre_tb_helper_code = pre_tb_helper_code;\r\n        tpi->pre_tb_helper_data = pre_tb_helper_data;\r\n    }\r\n\r\n\r\nPerformance Impact\r\n==================\r\n\r\nHow to reproduce\r\n----------------\r\n\r\n=============  ================================\r\nhost distro    Slackware64 13.37\r\nguest distro   ARMedSlack 13.37\r\nguest program  Links 2.3pre1 [#]_\r\ninput data     off-line version of a blog post_\r\nplugins        both per-block and per-opcode\r\n=============  ================================\r\n\r\n.. [#] mono-threaded console-based web-browser\r\n.. _post: http://perl6advent.wordpress.com/2011/12/14/meta-programming-what-why-and-how/\r\n\r\n\r\nResults\r\n-------\r\n\r\n======================================  ====================\r\nInstrumentation                         Slowdown\r\n======================================  ====================\r\nnone (reference)                                          0%\r\ninlined                                                  ~3%\r\nhelper does nothing                                    ~ 25%\r\nhelper does nothing, mutex protected             100% ~ 200%\r\nhelper calls getsymbol() @ translation             25% ~ 30%\r\nhelper calls getsymbol() @ execution                  ~ 900%\r\nhelper prints a in file @ execution            3000% ~ 5000%\r\n======================================  ====================\r\n\r\n\r\nConclusion\r\n----------\r\n\r\nDon't take these results to conclude about the TCG plugin support\r\nsince, as you can see, the slowdown heavily depends on the kind of\r\noperations made in the plugin itself: file IOs, execution-time\r\nvs. translation-time, inlining, mutex protection, ...",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}